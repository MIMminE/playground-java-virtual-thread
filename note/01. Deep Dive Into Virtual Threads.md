## Introduction

가상 스레드에 대한 깊은 이해를 위해서는 운영체제가 어떻게 동작하는지에 대한 수준 높은 이해가 필요하다. 그렇기에 이번 섹션에서는 운영체제와 관련한 기본적인 내용을 시작으로 가상 스레드의 이론적인 부분을 다룬다.

- `프로세스` : 컴퓨터 프로그램의 인스턴스로 각 프로세스는 독립적인 메모리 공간을 운영체제로부터 할당받는다. 프로세스는 생성되고 소멸하는 것에 많은 컴퓨터 리소스를 소모하며 상대적으로 무겁다고 볼 수 있다.
- `스레드` : 실행의 단위로 하나의 프로세스는 최소 하나 이상의 스레드를 포함한다. 같은 프로세스 내에 있는 스레드들은 프로세스의 메모리를 공유해서 사용한다.
    ```text
    프로세스는 리소스의 단위로, 스레드는 실행의 단위
    ```
- `스케줄러` : 스레드에 얼마만큼의 시간동안 CPU를 할당할지를 결정한다. 프로세서의 개수는 한정적이므로 여러 스레드들이 스케줄러의 통제 하에 번갈아가며 자신의 작업을 수행한다.

전통의 자바 스레드는 단순히 운영 체제 스레드의 래퍼로 동작하며, 실질적으로 운영체제 스케쥴러에 의해 관리되는 단위이다.
스레드의 동작에서 네트워크 호출 등에 의해 블로킹되는 경우 OS 스레드 자체가 블로킹이 되어 스케쥴러에 의해 다른 스레드로 컨텍스트 스위칭이 발생하게 된다.

전통적인 자바 스레드 모델에서는 네트워크 통신 등으로 인해 스레드가 블로킹 되면 운영체제 스레드 자체가 블로킹된다.
자바 가상 스레드는 경량 스레드 모델을 제공하여 이러한 블로킹 상황에서도 운영체제 스레드 자체는 블로킹되지 않도록 설계되었으며, 이는 스레드 간 컨텍스트 스위칭 비용을 줄이고 효율적인 자원 활용을 가능하게 한다.

## Platform Thread Creation Limit

현대의 웹 애플리케이션은 각 클라이언트 요청에 대해 별도의 스레드를 생성해 처리하는 것이 일반적이다.
특히 마이크로서비스 아키텍처에서는 네트워크 호출이 빈번하게 발생하기 때문에 많은 스레드가 필요하며, 스레드가 부족한 경우
새로운 스레드를 생성하여 이를 처리한다. 전통적으로 자바의 스레드는 운영체제에서 직접 관리되는 스레드와 1대1로 매핑하는 스레드이며 클라이언트 요청에 따라 
생성되는 스레드들도 결과적으로 운영체제에서 관리되는 스레드가 되는 것이다. 여기서 말하는 전통적인 스레드는 자바 진영에서 새롭게 등장한
`가상 스레드`와의 구별을 명확하게 하기 위해 `플랫폼 스레드`라는 명칭으로 사용한기로 했다.
---
#### 플랫폼 스레드 생성의 메모리 부족 현상
플랫폼 스레드는 고정된 크기의 스택 메모리를 할당받는 특징이 있다. 현대 컴퓨터 환경에서는 가상 메모리 기법이 기본적으로 사용되므로
스레드가 할당받은 스택 메모리가 실제 물리 메모리에 바로 적재되어 메모리를 소모하지는 않는다. 즉, 스택 메모리 중 실제로 사용되는 부분만 물리 메모리로 로드되고,
나머지 부분은 가상 메모리 공간에서 관리되는데 이러한 방식 덕분에 플랫폼 스레드를 많이 생성하더라도 물리 메모리 부족 현상은 쉽게 발생하지 않는다.
그러나 가상 메모리라도 스택에 할당된 크기만큼 기억장치의 스왑 영역의 공안을 차지하게 되므로 그로인한 리소스 낭비가 발생하기는 한다. 

#### 경량화된 JVM 가상 스레드
플랫폼 스레드는 운영체제에서 관리되는 OS 스레드가 함께 생성되어 매핑되며 이 과정에서 운영체제 자원 사용에 대한 오버헤드가 발생하게 된다. 
이러한 점 때문에 일반적으로 `스레드 생성 비용은 높다` 라고 보는 것이다. 자바 가상 스레드는 운영체제 스레드를 생성하지 않고 클래스 인스턴스를 생성하듯 스레드를 생성하고 JVM 레벨에서 관리한다는 특징이 있다. 이로 인해 생성과 관리에 비용이 플랫폼 스레드보다 현저히 적다.

## Thread Builder - Factory Method

자바 21부터 새로운 방식의 스레드 생성 API 가 제공된다. 이 방식은 팩토리 패턴을 활용해 아래와 같이 사용한다.

```java
public void platformBuilder() {
    Thread thread = Thread.ofPlatform().unstarted(() -> Task.ioIntensive(j));
    thread.start();
}
```

스레드 빌더 개념이 도입된 것으로 아래와 같이 빌더 클래스를 인스턴스로 가지고 있다가 필요에 따라 생성하는 방식으로 응용할 수 있다.
```java
public void platformBuilder() {

    // 플랫폼 스레드를 만들기 위한 빌더 객체를 반환한다.
    // 빌더 객체를 통해 만들어질 스레드의 이름과 초기 숫자를 지정한다.
    Thread.Builder.ofPlatform builder = Thread.ofPlatform().name("vins", 1);
    // var builder = Thread.ofPlatform().name("vins", 1); 처럼 사용해도 괜찮다. (추론 타입) 
    
    // vins-1, vins-2 순서로 스레드 이름이 부여된다.
    for (int i = 0; i < MAX_PLATFORM; i++) {
        int j = i;
        Thread thread = builder.unstarted(() -> Task.ioIntensive(j));
        thread.start();
    }
}
```
위 코드에서 생성되고 실행되는 플랫폼 스레드는 `포그라운드 스레드`이며, `백그라운드 스레드` 또는 `데몬 스레드`는 별도의 생성 api를 제공한다.
```java
var builder = Thread.ofPlatform().daemon().name("daemon", 1);
// 해당 빌더 인스턴스를 통해 만들어진 스레드는 모두 데몬 스레드가 된다.
```
---
#### 백그라운드 스레드의 종료 지연
메인 스레드가 종료되면 백그라운드 스레드는 작업이 완료되지 않았더라도 JVM에 의해 강제적으로 종료된다. 백그라운 스레드의 의도된 동작이기는 하지만 
백그라운드 스레드의 동작이 완료될 때까지 메인 스레드의 흐름을 중단시키는 방법으로 `ConutDownLatch` 와 `Thread.join`가 있다.

```java
public void countDownLatch() { // 해당 메서드가 메인 스레드에서 실행되어야 제대로 동작한다.
    
    final int numberOfThreads = 10;
    CountDownLatch latch = new CountDownLatch(numberOfThreads);

    for (int i = 0; i < numberOfThreads; i++) {
        // 플랫폼 데몬 스레드 생성
        Thread thread = Thread.ofPlatform().daemon().start(() -> {
            try {
                // 스레드의 작업 수행
                System.out.println(Thread.currentThread().getName() + " is working.");
            } finally {
                latch.countDown(); // 작업 완료 시 카운트다운
            }
        });

        // 스레드 시작
        thread.start();
    }

    try {
        // 모든 스레드가 완료될 때까지 대기
        latch.await();
        System.out.println("All threads have completed their tasks.");
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        System.out.println("Main thread interrupted.");
    }
}
```

## Virtual Thread Scaling
가상 스레드는 플랫폼 스레드의 생성 및 관리의 무거움을 해결하기 위한 자바 경량 스레드 모델로, 기존의 스레드 사용법을 거의 그대로 사용할 수 있도록 개발되었다.
기본적으로 모든 생성되는 모든 가상 스레드는 백그라운드 스레드 성격을 지닌다. 
```java
public void createVirtualThread(){
    
    var builder = Thread.ofVirtual().name("virtual-", 1);
    
    Thread thread = builder.unstarted(() -> {
       // .. 스레드 로직 
    });
    
    thread.start();
}
```

## How Virtual Thread Works
가상 스레드는 자바 클래스 인스턴스처럼 생성되며 실제로 JVM 의 힙 영역에 저장된다. 스레드 내 동작의 흐름을 위한 스택 구조도 내부적으로 가지고 있으며 
플랫폼 스레드처럼 고정적인 크기를 할당받는 것이 아닌, 힙 영역에서 동적으로 증가 또는 감소한다.

추상적으로 생각하자면 가상 스레드는 실행하고자 하는 `Runnable 인스턴스`와 `Stack 인스턴스`를 가지고 있는 하나의 클래스라고 볼 수도 있다.

---

#### 가상 스레드의 실행
코드의 실행은 반드시 운영체제를 거쳐 컴퓨팅 리소스를 사용해야만 가능하다는 점에서 실제 OS 스레드가 필요로 하는 것은 변함이 없다.
가상 스레드의 실행도 OS 스레드가 필요하며 이를 `캐리어 스레드`라고 한다. 이 스레드는 새로운 개념이 아닌 기존의 플랫폼 스레드와 동일하지만 
가상 스레드의 실행을 대신 해준다는 것에 차이가 있다.
1. 실행하고자 하는 Runnable 객체와 스택을 가진 가상 스레드 인스턴스를 생성하고 JVM 힙 메모리에 저장한다.
2. 가상 스레드를 실행할 캐리어 스레드 풀을 생성하고, 실행을 원하는 가상 스레드 인스턴스들을 스레드 풀의 작업 큐에 추가한다. 
3. 캐리어 스레드 풀의 워커 스레드들에 가상 스레드의 작업을 `마운트(Mount)`하여 실행한다.
4. 워커 스레드가 실행 중 네트워크 호출과 같은 블로킹을 만나게 되면 워커 스레드를 블로킹하는 것이 아닌 진행하던 가상 스레드 작업은 언마운트`(Unmount)`한다.
5. 언마운트된 가상 스레드는 현재까지의 작업 현황을 자신의 스택에 저장하고, 블로킹이 완료될 때까지 대기하다가 완료 이후 다시 캐리어 스레드 풀의 작업 큐에 추가된다.

가상 스레드의 실행의 핵심은 블로킹이 발생했을떄, OS 스레드를 블로킹하는 것이 아닌 대기 중인 다른 작업을 가져와서 계속 진행함으로써 OS 스레드가 블로킹되어 
CPU 점유가 다른 스레드에게로 넘어가는 컨텍스트 스위칭을 최소화하는 것에 있다.












